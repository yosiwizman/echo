name: Backend Runtime Smoke Monitor

# Runtime smoke tests that continuously validate staging and production deployments.
# This is NOT a PR check - it runs on schedule and manual dispatch only.

on:
  schedule:
    # Every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      skip_staging:
        description: 'Skip staging checks'
        type: boolean
        default: false
      skip_production:
        description: 'Skip production checks'
        type: boolean
        default: false

jobs:
  runtime-smoke:
    name: Runtime Smoke Check
    runs-on: ubuntu-latest

    steps:
      - name: Install jq
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq

      - name: Validate configuration
        run: |
          echo "=== Configuration Check ==="
          
          MISSING=""
          
          if [ -z "${{ vars.STAGING_BASE_URL }}" ]; then
            MISSING="${MISSING}  - STAGING_BASE_URL\n"
          fi
          
          if [ -z "${{ vars.PROD_BASE_URL }}" ]; then
            MISSING="${MISSING}  - PROD_BASE_URL\n"
          fi
          
          if [ -n "$MISSING" ]; then
            echo "❌ Missing required GitHub Actions Variables:"
            echo -e "$MISSING"
            echo ""
            echo "Set these at: https://github.com/${{ github.repository }}/settings/variables/actions"
            echo ""
            echo "See docs/ops/runtime_smoke_monitoring.md for setup instructions."
            exit 1
          fi
          
          echo "✓ STAGING_BASE_URL: ${{ vars.STAGING_BASE_URL }}"
          echo "✓ PROD_BASE_URL:    ${{ vars.PROD_BASE_URL }}"

      - name: Smoke test - Staging
        if: ${{ github.event.inputs.skip_staging != 'true' }}
        env:
          BASE_URL: ${{ vars.STAGING_BASE_URL }}
          EXPECTED_ENV: staging
        run: |
          echo "=============================================="
          echo "  STAGING RUNTIME SMOKE TEST"
          echo "  Base URL: $BASE_URL"
          echo "=============================================="
          
          RESULTS=""
          FAILURES=0
          
          # Function: curl with retries
          curl_retry() {
            local url="$1"
            local max_retries=5
            local retry_delay=3
            
            for i in $(seq 1 $max_retries); do
              HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" --connect-timeout 10 --max-time 30 "$url" 2>/dev/null)
              if [ "$HTTP_CODE" = "200" ]; then
                cat /tmp/response.json
                return 0
              fi
              echo "  Attempt $i/$max_retries failed (HTTP $HTTP_CODE), retrying in ${retry_delay}s..." >&2
              sleep $retry_delay
              retry_delay=$((retry_delay * 2))
            done
            
            echo "  All $max_retries attempts failed" >&2
            cat /tmp/response.json 2>/dev/null || echo "{}"
            return 1
          }
          
          # Function: validate /health endpoint (simple check)
          validate_health() {
            local url="${BASE_URL}/health"
            
            echo ""
            echo "--- Testing: $url ---"
            
            # Fetch with retries
            RESPONSE=$(curl_retry "$url")
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -ne 0 ]; then
              echo "  ❌ FAIL: Could not reach endpoint after retries"
              return 1
            fi
            
            echo "  Response: $RESPONSE"
            
            # Parse JSON
            if ! echo "$RESPONSE" | jq . > /dev/null 2>&1; then
              echo "  ❌ FAIL: Response is not valid JSON"
              return 1
            fi
            
            # Check status field
            STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
            if [ -z "$STATUS" ]; then
              echo "  ❌ FAIL: Missing 'status' field"
              return 1
            elif [ "$STATUS" != "ok" ]; then
              echo "  ❌ FAIL: status is '$STATUS', expected 'ok'"
              return 1
            fi
            
            echo "  ✓ PASS"
            echo "    status: $STATUS"
            return 0
          }
          
          # Function: validate /version endpoint (full metadata check)
          validate_version() {
            local url="${BASE_URL}/version"
            
            echo ""
            echo "--- Testing: $url ---"
            
            # Fetch with retries
            RESPONSE=$(curl_retry "$url")
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -ne 0 ]; then
              echo "  ❌ FAIL: Could not reach endpoint after retries"
              return 1
            fi
            
            echo "  Response: $RESPONSE"
            
            # Parse JSON
            if ! echo "$RESPONSE" | jq . > /dev/null 2>&1; then
              echo "  ❌ FAIL: Response is not valid JSON"
              return 1
            fi
            
            local errors=""
            
            # Check env field
            ACTUAL_ENV=$(echo "$RESPONSE" | jq -r '.env // empty')
            if [ -z "$ACTUAL_ENV" ]; then
              errors="${errors}  - Missing 'env' field\n"
            elif [ "$ACTUAL_ENV" != "$EXPECTED_ENV" ]; then
              errors="${errors}  - env mismatch: expected '$EXPECTED_ENV', got '$ACTUAL_ENV'\n"
            fi
            
            # Check git_sha field
            GIT_SHA=$(echo "$RESPONSE" | jq -r '.git_sha // empty')
            if [ -z "$GIT_SHA" ]; then
              errors="${errors}  - Missing 'git_sha' field\n"
            elif [ "$GIT_SHA" = "unknown" ]; then
              errors="${errors}  - git_sha is 'unknown' (deployment metadata not injected)\n"
            elif [ ${#GIT_SHA} -lt 7 ]; then
              errors="${errors}  - git_sha too short: '$GIT_SHA' (expected >= 7 chars)\n"
            fi
            
            # Check build_time field (basic ISO-like sanity check)
            BUILD_TIME=$(echo "$RESPONSE" | jq -r '.build_time // empty')
            if [ -z "$BUILD_TIME" ]; then
              errors="${errors}  - Missing 'build_time' field\n"
            elif ! echo "$BUILD_TIME" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}'; then
              errors="${errors}  - build_time not ISO-like: '$BUILD_TIME'\n"
            fi
            
            if [ -n "$errors" ]; then
              echo "  ❌ FAIL: Validation errors:"
              echo -e "$errors"
              return 1
            fi
            
            echo "  ✓ PASS"
            echo "    env:        $ACTUAL_ENV"
            echo "    git_sha:    $GIT_SHA"
            echo "    build_time: $BUILD_TIME"
            return 0
          }
          
          # Run tests
          if validate_health; then
            RESULTS="${RESULTS}| /health | ✓ PASS |\n"
          else
            RESULTS="${RESULTS}| /health | ❌ FAIL |\n"
            FAILURES=$((FAILURES + 1))
          fi
          
          if validate_version; then
            RESULTS="${RESULTS}| /version | ✓ PASS |\n"
          else
            RESULTS="${RESULTS}| /version | ❌ FAIL |\n"
            FAILURES=$((FAILURES + 1))
          fi
          
          # Summary table
          echo ""
          echo "=============================================="
          echo "  STAGING SUMMARY"
          echo "=============================================="
          echo "| Endpoint | Status |"
          echo "|----------|--------|"
          echo -e "$RESULTS"
          
          if [ $FAILURES -gt 0 ]; then
            echo ""
            echo "❌ $FAILURES staging endpoint(s) failed"
            exit 1
          else
            echo ""
            echo "✓ All staging endpoints passed"
          fi

      - name: Smoke test - Production
        if: ${{ github.event.inputs.skip_production != 'true' }}
        env:
          BASE_URL: ${{ vars.PROD_BASE_URL }}
          EXPECTED_ENV: production
        run: |
          echo "=============================================="
          echo "  PRODUCTION RUNTIME SMOKE TEST"
          echo "  Base URL: $BASE_URL"
          echo "=============================================="
          
          RESULTS=""
          FAILURES=0
          
          # Function: curl with retries
          curl_retry() {
            local url="$1"
            local max_retries=5
            local retry_delay=3
            
            for i in $(seq 1 $max_retries); do
              HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" --connect-timeout 10 --max-time 30 "$url" 2>/dev/null)
              if [ "$HTTP_CODE" = "200" ]; then
                cat /tmp/response.json
                return 0
              fi
              echo "  Attempt $i/$max_retries failed (HTTP $HTTP_CODE), retrying in ${retry_delay}s..." >&2
              sleep $retry_delay
              retry_delay=$((retry_delay * 2))
            done
            
            echo "  All $max_retries attempts failed" >&2
            cat /tmp/response.json 2>/dev/null || echo "{}"
            return 1
          }
          
          # Function: validate /health endpoint (simple check)
          validate_health() {
            local url="${BASE_URL}/health"
            
            echo ""
            echo "--- Testing: $url ---"
            
            # Fetch with retries
            RESPONSE=$(curl_retry "$url")
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -ne 0 ]; then
              echo "  ❌ FAIL: Could not reach endpoint after retries"
              return 1
            fi
            
            echo "  Response: $RESPONSE"
            
            # Parse JSON
            if ! echo "$RESPONSE" | jq . > /dev/null 2>&1; then
              echo "  ❌ FAIL: Response is not valid JSON"
              return 1
            fi
            
            # Check status field
            STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
            if [ -z "$STATUS" ]; then
              echo "  ❌ FAIL: Missing 'status' field"
              return 1
            elif [ "$STATUS" != "ok" ]; then
              echo "  ❌ FAIL: status is '$STATUS', expected 'ok'"
              return 1
            fi
            
            echo "  ✓ PASS"
            echo "    status: $STATUS"
            return 0
          }
          
          # Function: validate /version endpoint (full metadata check)
          validate_version() {
            local url="${BASE_URL}/version"
            
            echo ""
            echo "--- Testing: $url ---"
            
            # Fetch with retries
            RESPONSE=$(curl_retry "$url")
            CURL_STATUS=$?
            
            if [ $CURL_STATUS -ne 0 ]; then
              echo "  ❌ FAIL: Could not reach endpoint after retries"
              return 1
            fi
            
            echo "  Response: $RESPONSE"
            
            # Parse JSON
            if ! echo "$RESPONSE" | jq . > /dev/null 2>&1; then
              echo "  ❌ FAIL: Response is not valid JSON"
              return 1
            fi
            
            local errors=""
            
            # Check env field
            ACTUAL_ENV=$(echo "$RESPONSE" | jq -r '.env // empty')
            if [ -z "$ACTUAL_ENV" ]; then
              errors="${errors}  - Missing 'env' field\n"
            elif [ "$ACTUAL_ENV" != "$EXPECTED_ENV" ]; then
              errors="${errors}  - env mismatch: expected '$EXPECTED_ENV', got '$ACTUAL_ENV'\n"
            fi
            
            # Check git_sha field
            GIT_SHA=$(echo "$RESPONSE" | jq -r '.git_sha // empty')
            if [ -z "$GIT_SHA" ]; then
              errors="${errors}  - Missing 'git_sha' field\n"
            elif [ "$GIT_SHA" = "unknown" ]; then
              errors="${errors}  - git_sha is 'unknown' (deployment metadata not injected)\n"
            elif [ ${#GIT_SHA} -lt 7 ]; then
              errors="${errors}  - git_sha too short: '$GIT_SHA' (expected >= 7 chars)\n"
            fi
            
            # Check build_time field (basic ISO-like sanity check)
            BUILD_TIME=$(echo "$RESPONSE" | jq -r '.build_time // empty')
            if [ -z "$BUILD_TIME" ]; then
              errors="${errors}  - Missing 'build_time' field\n"
            elif ! echo "$BUILD_TIME" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}'; then
              errors="${errors}  - build_time not ISO-like: '$BUILD_TIME'\n"
            fi
            
            if [ -n "$errors" ]; then
              echo "  ❌ FAIL: Validation errors:"
              echo -e "$errors"
              return 1
            fi
            
            echo "  ✓ PASS"
            echo "    env:        $ACTUAL_ENV"
            echo "    git_sha:    $GIT_SHA"
            echo "    build_time: $BUILD_TIME"
            return 0
          }
          
          # Run tests
          if validate_health; then
            RESULTS="${RESULTS}| /health | ✓ PASS |\n"
          else
            RESULTS="${RESULTS}| /health | ❌ FAIL |\n"
            FAILURES=$((FAILURES + 1))
          fi
          
          if validate_version; then
            RESULTS="${RESULTS}| /version | ✓ PASS |\n"
          else
            RESULTS="${RESULTS}| /version | ❌ FAIL |\n"
            FAILURES=$((FAILURES + 1))
          fi
          
          # Summary table
          echo ""
          echo "=============================================="
          echo "  PRODUCTION SUMMARY"
          echo "=============================================="
          echo "| Endpoint | Status |"
          echo "|----------|--------|"
          echo -e "$RESULTS"
          
          if [ $FAILURES -gt 0 ]; then
            echo ""
            echo "❌ $FAILURES production endpoint(s) failed"
            exit 1
          else
            echo ""
            echo "✓ All production endpoints passed"
          fi

      - name: Smoke test - Web Staging
        if: ${{ github.event.inputs.skip_staging != 'true' && vars.WEB_STAGING_BASE_URL != '' }}
        env:
          BASE_URL: ${{ vars.WEB_STAGING_BASE_URL }}
        run: |
          echo "=============================================="
          echo "  WEB STAGING SMOKE TEST"
          echo "  Base URL: $BASE_URL"
          echo "=============================================="
          
          MAX_RETRIES=3
          RETRY_DELAY=5
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${BASE_URL}/" --connect-timeout 10 --max-time 30 || echo "000")
            
            if [ "$STATUS" = "200" ]; then
              echo "✓ Web Staging PASS (HTTP 200)"
              exit 0
            fi
            
            echo "  Got HTTP $STATUS, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done
          
          echo "❌ Web Staging FAIL after $MAX_RETRIES attempts"
          exit 1

      - name: Smoke test - Web Production
        if: ${{ github.event.inputs.skip_production != 'true' && vars.WEB_PROD_BASE_URL != '' }}
        env:
          BASE_URL: ${{ vars.WEB_PROD_BASE_URL }}
        run: |
          echo "=============================================="
          echo "  WEB PRODUCTION SMOKE TEST"
          echo "  Base URL: $BASE_URL"
          echo "=============================================="
          
          MAX_RETRIES=3
          RETRY_DELAY=5
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${BASE_URL}/" --connect-timeout 10 --max-time 30 || echo "000")
            
            if [ "$STATUS" = "200" ]; then
              echo "✓ Web Production PASS (HTTP 200)"
              exit 0
            fi
            
            echo "  Got HTTP $STATUS, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done
          
          echo "❌ Web Production FAIL after $MAX_RETRIES attempts"
          exit 1

      - name: Final summary
        if: always()
        run: |
          echo ""
          echo "=============================================="
          echo "  RUNTIME SMOKE MONITOR COMPLETE"
          echo "=============================================="
          echo ""
          echo "View detailed logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "If checks failed:"
          echo "  1. Check Cloud Run console for service health"
          echo "  2. Verify deployment succeeded with correct env vars"
          echo "  3. See docs/ops/runtime_smoke_monitoring.md for troubleshooting"
